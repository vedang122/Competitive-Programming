let's run dfs from the root and calculate for each vertex the first time we visited it (ğ‘¡ğ‘–ğ‘›) and the last time we visited it (ğ‘¡ğ‘œğ‘¢ğ‘¡).

void dfs(int v, int par = -1) {
    tin[v] = T++;
    for (auto to : g[v]) {
        if (to == par) continue;
        dfs(to, v);
    }
    tout[v] = T++;
}

Initially, ğ‘‡ equals zero. Now we have a beautiful structure giving us so much information about the tree. Consider all segments [ğ‘¡ğ‘–ğ‘›ğ‘£;ğ‘¡ğ‘œğ‘¢ğ‘¡ğ‘£]. We can see that there is no pair of intersecting segments. The pair of segments [ğ‘¡ğ‘–ğ‘›ğ‘£;ğ‘¡ğ‘œğ‘¢ğ‘¡ğ‘£] and [ğ‘¡ğ‘–ğ‘›ğ‘¢;ğ‘¡ğ‘œğ‘¢ğ‘¡ğ‘¢] is either non-intersecting at all or one segment lies inside the other one. The second beautiful fact is that for each vertex ğ‘¢ in the subtree of ğ‘£ the segment [ğ‘¡ğ‘–ğ‘›ğ‘¢;ğ‘¡ğ‘œğ‘¢ğ‘¡ğ‘¢] lies inside the segment [ğ‘¡ğ‘–ğ‘›ğ‘£;ğ‘¡ğ‘œğ‘¢ğ‘¡ğ‘£]. So, we can check if one vertex is the parent of the other: the vertex ğ‘£ is the parent of the vertex ğ‘¢ if and only if ğ‘¡ğ‘–ğ‘›ğ‘£â‰¤ğ‘¡ğ‘–ğ‘›ğ‘¢ and ğ‘¡ğ‘œğ‘¢ğ‘¡ğ‘¢â‰¤ğ‘¡ğ‘œğ‘¢ğ‘¡ğ‘£(vertex parent of itself too). 

This approach can be used for each vertical path (such a path from ğ‘¥ to ğ‘¦ that ğ‘™ğ‘ğ‘(ğ‘¥,ğ‘¦) is either ğ‘¥ or ğ‘¦).
