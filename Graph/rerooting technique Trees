Let's try to change the root from the vertex ğ‘£ to some adjacent to it vertex ğ‘¡ğ‘œ. Which states of dynamic programming will change? Only ğ‘‘ğ‘ğ‘£ and ğ‘‘ğ‘ğ‘¡ğ‘œ. Firstly, we need to "remove" the child ğ‘¡ğ‘œ from the subtree of the vertex ğ‘£: ğ‘‘ğ‘ğ‘£=ğ‘‘ğ‘ğ‘£âˆ’ğ‘šğ‘ğ‘¥(0,ğ‘‘ğ‘ğ‘¡ğ‘œ) (Basically remove occurence of dp[t0] from dp[v]). Then we need to "attach" the vertex ğ‘£ and make it a child of the vertex ğ‘¡ğ‘œ: ğ‘‘ğ‘ğ‘¡ğ‘œ=ğ‘‘ğ‘ğ‘¡ğ‘œ+ğ‘šğ‘ğ‘¥(0,ğ‘‘ğ‘ğ‘£) (Now add the impact of v on t0 as if it is the child of t0). Then we need to run this process recursively from ğ‘¡ğ‘œ (store the answer, reroot the tree and so on) and when it ends we need to "rollback" our changes. Now ğ‘£ is the root again and we can try the next child of ğ‘£ as the root.

void dfs(int s,int p)
{
    ans[s] = dp[s]; /// storing values for every root.
    for(int i:gp[s] )
    {
        //if(i==parent)continue
        if(i!=p)
        {
            // Following two lines will first remove i as child from s and then add s as child of i.
            dp[s] -= max(0, dp[i]);
            dp[i] += max(0, dp[s]);
            dfs(i, s);
            // Following two lines will rollback the changes so that this proces can be repeated for other children.
            dp[i] -= max(0, dp[s]);
            dp[s] += max(0, dp[i]);
        }
    }
    
}
