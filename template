//#include <bits/stdc++.h>
#include<iostream>
#include <iosfwd>
#include<limits.h>
#include <sstream>
#include <iomanip>
#include <iterator>
#include <algorithm>
#include <limits>
#include<stdio.h>
#include <queue>
#include <stack>
#include <math.h>
#include<string.h>
#include <unordered_map>
#include <map>
#include <unordered_set>
#include <set>
#include<vector>
#include <chrono>
#include <random>
using namespace std;
using namespace std::chrono;
#define fr(i,j,n)   for(lli i=j;i<(n);++i)
#define bk(i,j,n)   for(lli i=j;i>=n&&j>=n;--i)
#define pb push_back
#define m_p make_pair
#define Fs first
#define Sc second
#define endl "\n"
#define MOD 1000000007
#define present(c,x)    ((c).find(x) != (c).end())
#define run ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define ordered_set tree<lli, null_type,less<lli>, rb_tree_tag,tree_order_statistics_node_update>
#define debug1(x) cout<<#x<<" "<<x<<endl;
#define debug2(x,y) cout<<#x<<" "<<x<<" "<<#y<<" "<<y<<endl;
#define debug3(x,y,z) cout<<#x<<" "<<x<<" "<<#y<<" "<<y<<" "<<#z<<" "<<z<<endl;
#define mem(p,v) memset(p,(lli)v,sizeof p);
#define ub upper_bound
#define lb lower_bound
typedef long long int lli;
typedef vector<int> vi;
typedef pair<int,int> pi;
typedef vector<lli> vl;
typedef pair<lli,lli> pl;
inline lli max(lli a,lli b){ return a>b?a:b;}
inline lli min(lli a,lli b){ return a<b?a:b;}
inline lli max(vl a){return *max_element(a.begin(),a.end());}
inline lli min(vl a){return *min_element(a.begin(),a.end());}
inline lli min(lli a[],lli n){return *min_element(a,a+n);}
inline lli max(lli a[],lli n){return *max_element(a,a+n);}
inline lli sum(lli a[],lli n){return accumulate(a, a+n,0);}
inline lli sum(vl a){return accumulate(a.begin(), a.end(),0);}
const long long inf = 1e18;
/*
 #include <ext/pb_ds/assoc_container.hpp>
 #include <ext/pb_ds/tree_policy.hpp>
 using namespace __gnu_pbds;
 #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
 */
lli modpow(lli x,lli n){
    lli res=1;
    while(n>0){
        if(n&1) res=((res%MOD)*(x%MOD))%MOD;
        x=((x%MOD)*(x%MOD))%MOD;
        n>>=1;
    }
    return res;
}
lli power(lli x, lli n)
{
    lli res=1;
    while(n>0){
        if(n&1) res=res*x;
        x=x*x;
        n>>=1;
    }
    return res;
}
void show(vector<lli> v)
{
    fr(i,0,v.size())
    cout<<v[i]<<" ";
    cout<<endl;
}
void show(vector<int> v)
{
    fr(i,0,v.size())
    cout<<v[i]<<" ";
    cout<<endl;
}
void show(int a[], int arraysize)
{
    for (int i = 0; i < arraysize; ++i)
        cout << a[i] << " ";
    cout<<endl;
}
void show(lli a[], lli arraysize)
{
    for (lli i = 0; i < arraysize; ++i)
        cout << a[i] << " ";
    cout<<endl;
}
void show(set<lli> s)
{
    for (auto it = s.begin(); it != s.end(); it++)
    {
        cout << *it << " ";
    }
    cout<<endl;
}
void show(map<lli,lli> mp)
{
    for (auto it = mp.begin(); it != mp.end(); it++)
    {
        cout << it->first << " "<<it->second<<endl;
    }
    cout<<endl;
}
bool comp(pair<lli,lli> p1,pair<lli,lli> p2){return p1.Fs<p2.Fs;}

int main()
{
    run;
    lli n,t;
    cin>>t;
    while(t)
    {
        cin>>n;
        
        t--;
    }
    return 0;
}
