//#include <bits/stdc++.h>
#include<iostream>
#include <iosfwd>
#include<limits.h>
#include <sstream>
#include <iomanip>
#include <iterator>
#include <algorithm>
#include <limits>
#include<stdio.h>
#include <queue>
#include <stack>
#include <math.h>
#include<string.h>
#include <unordered_map>
#include <map>
#include <unordered_set>
#include <set>
#include<vector>
#include <chrono>
#include <random>
using namespace std;
using namespace std::chrono;
#define fr(i,j,n)   for(lli i=j;i<(n);++i)
#define bk(i,j,n)   for(lli i=j;i>=n&&j>=n;--i)
#define pb push_back
#define m_p make_pair
#define Fs first
#define Sc second
#define all(v) (v.begin(),v.end())
#define endl "\n"
#define MOD 1000000007
#define present(c,x)    ((c).find(x) != (c).end())
#define run ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)
#define ordered_set tree<lli, null_type,less<lli>, rb_tree_tag,tree_order_statistics_node_update>
#define debug1(x) cout<<#x<<" "<<x<<endl;
#define debug2(x,y) cout<<#x<<" "<<x<<" "<<#y<<" "<<y<<endl;
#define debug3(x,y,z) cout<<#x<<" "<<x<<" "<<#y<<" "<<y<<" "<<#z<<" "<<z<<endl;
#define mem(p,v) memset(p,(lli)v,sizeof p);
#define ub upper_bound
#define lb lower_bound
/*
 #include <ext/pb_ds/assoc_container.hpp>
 #include <ext/pb_ds/tree_policy.hpp>
 using namespace __gnu_pbds;
 #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
 */
typedef long long int lli;
typedef vector<int> vi;
typedef pair<int,int> pi;
typedef vector<lli> vl;
typedef pair<lli,lli> pl;
inline lli max(lli a,lli b){ return a>b?a:b;}
inline lli min(lli a,lli b){ return a<b?a:b;}
inline lli max(vl a){return *max_element(a.begin(),a.end());}
inline lli min(vl a){return *min_element(a.begin(),a.end());}
inline lli min(lli a[],lli n){return *min_element(a,a+n);}
inline lli max(lli a[],lli n){return *max_element(a,a+n);}
inline lli sum(lli a[],lli n){lli s=0;fr(i,0,n)s+=a[i];return s;}
inline lli sum(vl a){lli s=0;fr(i,0,a.size())s+=a[i];return s;}
const long long inf = 1e18;
double pie = 2*acos(0.0);
void show(vector<lli> v){fr(i,0,v.size())cout<<v[i]<<" ";cout<<endl;}
void show(vector<int> v){fr(i,0,v.size())cout<<v[i]<<" ";cout<<endl;}
void show(int a[], int arraysize){for (int i = 0; i < arraysize; ++i)cout << a[i] << " ";cout<<endl;}
void show(lli a[], lli arraysize){for (lli i = 0; i < arraysize; ++i)cout << a[i] << " ";cout<<endl;}
void show(bool a[], lli arraysize){for (lli i = 0; i < arraysize; ++i)cout << a[i] << " ";cout<<endl;}
void show(set<int> s){for (auto it = s.begin(); it != s.end(); it++){cout << *it << " ";}cout<<endl;}
void show(map<lli,lli> mp){for (auto it = mp.begin(); it != mp.end(); it++){cout << it->first << " "<<it->second<<endl;}cout<<endl;}
bool comp(pair<lli,lli> p1,pair<lli,lli> p2){return p1.Fs>p2.Fs;}
lli modpow(lli x,lli n){
    lli res=1;
    while(n>0){
        if(n&1) res=((res%MOD)*(x%MOD))%MOD;
        x=((x%MOD)*(x%MOD))%MOD;
        n>>=1;
    }
    return res;
}
lli power(lli x, lli n)
{
    lli res=1;
    while(n>0){
        if(n&1) res=res*x;
        x=x*x;
        n>>=1;
    }
    return res;
}
/////// ------ Main code starts here ------ /////
int main()
{
    run;
    lli n,t;
    cin>>t;
    while(t)
    {
        cin>>n;
        
        t--;
    }
    return 0;
}
